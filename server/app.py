from flask import Flask, request, jsonify, send_file
import subprocess, os
import ssl
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger("ca_server")

app = Flask(__name__)

# Resolve absolute paths
HERE      = os.path.abspath(os.path.dirname(__file__))
CA_DIR    = os.path.abspath(os.path.join(HERE, '../ca'))
OPENSSL_CNF = os.path.join(CA_DIR, 'openssl.cnf')

@app.route("/enroll", methods=["POST"])
def enroll():
    csr_file       = os.path.join(HERE, "device.csr")
    raw_crt_file   = os.path.join(HERE, "device_raw.crt")
    clean_crt_file = os.path.join(HERE, "device.crt")

    # Save incoming CSR
    with open(csr_file, "wb") as f:
        f.write(request.files["csr"].read())

    # Remove old certs
    for fpath in (raw_crt_file, clean_crt_file):
        if os.path.exists(fpath):
            os.remove(fpath)

    # Sign CSR with CA (capture output and return helpful errors)
    try:
        logger.info('Signing CSR using openssl ca (cwd=%s)', CA_DIR)
        result = subprocess.run([
            "openssl", "ca",
            "-config", OPENSSL_CNF,
            "-in", csr_file,
            "-out", raw_crt_file,
            "-batch"
        ], capture_output=True, text=True, check=True, cwd=CA_DIR)
    except subprocess.CalledProcessError as e:
        logger.error('OpenSSL ca failed: returncode=%s stdout=%s stderr=%s', e.returncode, e.stdout, e.stderr)
        stderr = e.stderr or ''
        # Detect duplicate certificate error
        if 'There is already a certificate for' in stderr:
            # Try to extract serial number
            import re
            m = re.search(r"Serial Number\s*:\s*([0-9A-Fa-f]+)", stderr)
            serial = m.group(1) if m else None
            detail = {"error": "DuplicateCertificate", "message": "There is already a certificate for this subject."}
            if serial:
                detail['existing_serial'] = serial
                possible_path = os.path.join(CA_DIR, 'newcerts', f"{serial}.pem")
                if os.path.exists(possible_path):
                    detail['existing_cert'] = possible_path
            # If client requested force, attempt to revoke and retry
            force = request.values.get('force') in ('1', 'true', 'yes', 'True')
            if force and serial:
                try:
                    logger.info('Force flag present: revoking existing cert %s', serial)
                    cert_path = os.path.join(CA_DIR, 'newcerts', f"{serial}.pem")
                    if not os.path.exists(cert_path):
                        # Try other possible filename patterns (decimal)
                        cert_path = os.path.join(CA_DIR, 'newcerts', f"{int(serial)}.pem") if serial.isdigit() else cert_path
                    subprocess.run(["openssl", "ca", "-config", OPENSSL_CNF, "-revoke", cert_path], capture_output=True, text=True, check=True, cwd=CA_DIR)
                    # regenerate CRL
                    crl_out = os.path.join(CA_DIR, 'crl.pem')
                    subprocess.run(["openssl", "ca", "-config", OPENSSL_CNF, "-gencrl", "-out", crl_out], capture_output=True, text=True, check=True, cwd=CA_DIR)
                    logger.info('Revocation and CRL generation successful; retrying sign')
                    # Retry signing once
                    result = subprocess.run([
                        "openssl", "ca",
                        "-config", OPENSSL_CNF,
                        "-in", csr_file,
                        "-out", raw_crt_file,
                        "-batch"
                    ], capture_output=True, text=True, check=True, cwd=CA_DIR)
                except subprocess.CalledProcessError as e2:
                    logger.error('Retry after revoke failed: %s %s', e2.stdout, e2.stderr)
                    detail.update({"retry_stdout": e2.stdout, "retry_stderr": e2.stderr})
                    return jsonify(detail), 500
            else:
                return jsonify(detail), 409
        # generic failure
        return jsonify({
            "error": "OpenSSL ca failed",
            "returncode": e.returncode,
            "stdout": e.stdout,
            "stderr": e.stderr
        }), 500

    if not os.path.exists(raw_crt_file):
        logger.error('Expected output file not found after openssl ca: %s', raw_crt_file)
        return jsonify({"error": "Certificate not generated by OpenSSL ca"}), 500

    # Convert to clean PEM
    try:
        clean = subprocess.run([
            "openssl", "x509",
            "-in", raw_crt_file,
            "-out", clean_crt_file,
            "-outform", "PEM"
        ], capture_output=True, text=True, check=True)
    except subprocess.CalledProcessError as e:
        logger.error('OpenSSL x509 conversion failed: returncode=%s stdout=%s stderr=%s', e.returncode, e.stdout, e.stderr)
        return jsonify({
            "error": "OpenSSL x509 conversion failed",
            "returncode": e.returncode,
            "stdout": e.stdout,
            "stderr": e.stderr
        }), 500

    return send_file(clean_crt_file, mimetype="application/x-pem-file")

@app.route('/telemetry', methods=['POST'])
def telemetry():
    """Accept device telemetry (JSON) and update monitor data/status.json"""
    try:
        # Basic authentication by TLS client cert is enforced by the SSLContext
        data = request.get_json()
        if not data:
            logger.warning("Telemetry: invalid JSON payload")
            return jsonify({"error": "Invalid JSON payload"}), 400

        device_id = data.get("device_id") or data.get("device")
        if not device_id:
            logger.warning("Telemetry: missing device_id in payload")
            return jsonify({"error": "Missing device_id"}), 400

        # Validate timestamp
        ts = data.get("timestamp")
        try:
            if ts:
                # Accept ISO format timestamps
                datetime.fromisoformat(ts.replace('Z', '+00:00'))
        except Exception:
            logger.warning("Telemetry: invalid timestamp for device %s: %s", device_id, ts)
            return jsonify({"error": "Invalid timestamp format"}), 400

        # Ensure sensors is an object
        sensors = data.get("sensors")
        if sensors is not None and not isinstance(sensors, dict):
            logger.warning("Telemetry: sensors not an object for device %s", device_id)
            return jsonify({"error": "Invalid sensors format"}), 400

        # Build path to monitor data file
        status_file = os.path.abspath(os.path.join(HERE, '..', 'monitor', 'data', 'status.json'))
        os.makedirs(os.path.dirname(status_file), exist_ok=True)

        # Load existing statuses
        if os.path.exists(status_file):
            with open(status_file, 'r') as f:
                statuses = json.load(f)
        else:
            statuses = {}

        # Update status for device
        statuses[device_id] = {
            "last_seen": ts,
            "status": data.get("status", "online"),
            "sensors": sensors,
        }

        with open(status_file, 'w') as f:
            json.dump(statuses, f, indent=2)

        logger.info("Telemetry accepted from %s", device_id)
        return jsonify({"success": True}), 200
    except Exception as e:
        logger.exception("Telemetry endpoint error")
        return jsonify({"error": "Internal server error"}), 500

@app.route('/logs')
def get_logs():
    index_path = os.path.join(CA_DIR, 'index.txt')
    if os.path.exists(index_path):
        with open(index_path, 'r') as f:
            return f.read()
    return "Index file not found", 404

if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(name)s: %(message)s')
    # TLS server context for CA server
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    certfile = os.path.join(CA_DIR, 'certs', 'ca.crt')
    keyfile = os.path.join(CA_DIR, 'private', 'ca.key')
    context.load_cert_chain(certfile=certfile, keyfile=keyfile)

    logger.info("Starting CA server on 0.0.0.0:5000")
    app.run(host='0.0.0.0', port=5000, ssl_context=context, debug=True)